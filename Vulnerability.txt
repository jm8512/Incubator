Passwords: Hardcoded Passwords in Source Files
Test Case:  hardcoded_pw.py, SSL_hardcoded_pw.py
 
Storing plaintext passwords in source files increases the risk that the application will be compromised. An attacker can gain access to source code repositories such as GitHub or a compromised developer machine. This will leave the passwords exposed and easily identifiable. See SampleNetworkServer.py:line 61 SampleNetworkClient.py:lines 56,67


Test Cases connect to the server and send “AUTH !Q#E%T&U8i6y4r2w”, receive a valid token, and use the token to obtain temperature data. This demonstrates that with a publicly available password we’re able to authenticate to the incubators and access private data.


 *NOTE: See README for instruction on .env file
Remediation was achieved by removing hardcoded passwords from the source files. Instead we used environment variables in the source code. An assumption will be that end users will have the ability to and will change the default passwords stored in the environment variables either through a future change password command or by some other means. See SSLServer.py:line 16,18,19,77 SSLClient.py:lines 10,11,72,83


Authentication Bypass
Test Case:  auth_bypass.py, SSL_auth_bypass.py
 
We were able to execute post-authentication commands without properly authenticating to the SampleNetworkServer. For example, our test script sends an erroneous Auth value immediately followed by a semicolon and command. The server would then process the Auth command and immediately process the next command that was semicolon delimited. This is due to the code continuing to process commands after it detects a bad AUTH value. See SampleNetworkServer.py:line 61-67


Test Cases connect to the server and send “AUTH X;GET_TEMP” to demonstrate that even with an invalid password we’re able to obtain the temperature.
 
Remediation was achieved by adding an else to the password check for both AUTH and LOGOUT commands. This tests if the password did not match else send “Invalid Auth” message and then break from the for loop to prevent running additional commands. See SSLServer.py:line 77-88 


Authentication Token Unencrypted In Transit
Test Case:  token_steal.py, SSL_token_steal.py
 
The application's authentication token is sent unencrypted. Authentication tokens allow you to send post authenticated commands to the SampleNetworkServer.. Sending these tokens unencrypted increases the risk of session hijacking and can lead to other forms of sensitive information leakage that should be avoided.  See SampleNetworkServer.py:line 34-43 SampleNetworkClient.py:lines 41-42,48-49




Test Cases listen on the network for packets communicating with the known ports of the incubator programs.  Sniffing the communications it will look for a string matching the length of a token with a semicolon after it and utilize that token for sending its own GET_TEMP command. Utilize SimpleNetworkClient.py and SSLClient.py to test the sniffing test case program.


 *NOTE: See README for instruction on creating certificates.
Remediation can be achieved by enabling TLS to encrypt the network traffic of the application’s communications and protect the confidentiality of any data contained in the transmissions.This prevents man-in-the-middle attacks and securely transmits the authentication token over the network. Due to unforeseen issues we were not able to get  UDP to work over TLS. As a proof of concept we switched to TCP. See SSLServer.py:line 34-43 SSLClient.py:lines 47-53,59-65


Denial of Service: Logout Function 
 Test Case:  forced_logout.py, SSL_forced_logoutl.py


A denial/disruption of service (DoS) weakness was identified related to the design of the application Logout function. If an attacker can gain access to the Auth Token he can script the logout command to be sent preventing the valid user or service from accessing the server. This type of abusive scenario would be motivated by a desire to disrupt the incubators operations by overloading the system with invalid information. See SampleNetworkServer.py:line 34-43 SampleNetworkClient.py:lines 41-42,48-49
 
Test Cases listen on the network for packets communicating with the known ports of the incubator programs.  Sniffing the communications it will look for a string matching the length of a token with a semicolon after it and utilize that token for sending LOGOUT commands. This will disrupt normal operations of the incubator and prevent authorized use of the product. Utilize SimpleNetworkClient.py and SSLClient.py to test the sniffing test case program.


 *NOTE: See README for instruction on creating certificates.
Remediation can be achieved by enabling TLS to encrypt the network traffic of the application’s communications and protect the confidentiality of any data contained in the transmissions..This prevents man-in-the-middle attacks and securely transmits the authentication token over the network. This prevents the abuse of the applications logout function. Due to unforeseen issues we were not able to get  UDP to work over TLS. As a proof of concept we switched to TCP. See SSLServer.py:line 34-43 SSLClient.py:lines 47-53,59-65


Sensitive Data Transmitted in Clear Text
 Demonstrated by test Cases:  token_steal.py, SSL_token_steal.py and forced_logout.py, SSL_forced_logoutl.py


Sensitive data must not be transmitted unencrypted. This device is a medical device and must follow regulations and laws such as HIPAA. The data transmitted by these devices is personal medical data of the infant. See SampleNetworkServer.py:line 34-43 SampleNetworkClient.py:lines 41-42,48-49


Test cases above demonstrate we can obtain a token value from the communications between client and server. It is also possible for an attacker to simply listen in for the temperature data being transmitted to obtain what should be confidential data.


 *NOTE: See README for instruction on creating certificates.
Remediation can be achieved by enabling TLS to encrypt the network traffic of the application’s communications and protect the confidentiality of any data contained in the transmissions..This prevents man-in-the-middle attacks and securely transmits the medical data over the network. Due to unforeseen issues we were not able to get  UDP to work over TLS. As a proof of concept we switched to TCP. See SSLServer.py:line 34-43 SSLClient.py:lines 47-53,59-65